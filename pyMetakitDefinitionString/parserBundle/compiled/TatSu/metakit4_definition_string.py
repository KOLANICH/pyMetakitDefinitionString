#!/usr/bin/env python
# -*- coding: utf-8 -*-

# CAVEAT UTILITOR
#
# This file was automatically generated by TatSu.
#
#    https://pypi.python.org/pypi/tatsu/
#
# Any changes you make to it will be overwritten the next time
# the file is generated.


from __future__ import generator_stop

import sys

from tatsu.buffering import Buffer
from tatsu.parsing import Parser
from tatsu.parsing import tatsumasu, leftrec, nomemo
from tatsu.parsing import leftrec, nomemo  # noqa
from tatsu.util import re, generic_main  # noqa


KEYWORDS = {}  # type: ignore


class metakit4_definition_stringBuffer(Buffer):
    def __init__(
        self,
        text,
        whitespace=None,
        nameguard=None,
        comments_re=None,
        eol_comments_re=None,
        ignorecase=None,
        namechars='',
        **kwargs
    ):
        super().__init__(
            text,
            whitespace=whitespace,
            nameguard=nameguard,
            comments_re=comments_re,
            eol_comments_re=eol_comments_re,
            ignorecase=ignorecase,
            namechars=namechars,
            **kwargs
        )


class metakit4_definition_stringParser(Parser):
    def __init__(
        self,
        whitespace=None,
        nameguard=None,
        comments_re=None,
        eol_comments_re=None,
        ignorecase=None,
        left_recursion=False,
        parseinfo=True,
        keywords=None,
        namechars='',
        tokenizercls=metakit4_definition_stringBuffer,
        **kwargs
    ):
        if keywords is None:
            keywords = KEYWORDS
        super().__init__(
            whitespace=whitespace,
            nameguard=nameguard,
            comments_re=comments_re,
            eol_comments_re=eol_comments_re,
            ignorecase=ignorecase,
            left_recursion=left_recursion,
            parseinfo=parseinfo,
            keywords=keywords,
            namechars=namechars,
            tokenizercls=tokenizercls,
            **kwargs
        )

    @tatsumasu()
    def _subFields_(self):  # noqa
        self._scalarOrView_()
        self.name_last_node('first_subField')
        self._rest_subFields_with_delF_()
        self.name_last_node('rest_subFields_with_del')
        self.ast._define(
            ['first_subField', 'rest_subFields_with_del'],
            []
        )

    @tatsumasu()
    def _scalarOrView_(self):  # noqa
        with self._choice():
            with self._option():
                self._scalar_()
                self.name_last_node('scalarF')
            with self._option():
                self._view_()
                self.name_last_node('viewF')
            self._error('expecting one of: scalar view word')
        self.ast._define(
            ['scalarF', 'viewF'],
            []
        )

    @tatsumasu()
    def _view_(self):  # noqa
        self._word_()
        self.name_last_node('name')
        self._SubFieldsStart_()
        self._body_()
        self.name_last_node('bodyF')
        self._SubFieldsEnd_()
        self.ast._define(
            ['bodyF', 'name'],
            []
        )

    @tatsumasu()
    def _scalar_(self):  # noqa
        self._word_()
        self.name_last_node('name')
        self._Colon_()
        self._TypeSpecifier_()
        self.name_last_node('typeF')
        self.ast._define(
            ['name', 'typeF'],
            []
        )

    @tatsumasu()
    def _body_(self):  # noqa
        with self._choice():
            with self._option():
                self._subFields_()
                self.name_last_node('subFieldsF')
            with self._option():
                self._IndirectMarker_()
                self.name_last_node('selfF')
            self._error('expecting one of: IndirectMarker ^ scalar scalarOrView subFields view')
        self.ast._define(
            ['selfF', 'subFieldsF'],
            []
        )

    @tatsumasu()
    def _rest_subFields_with_delF_(self):  # noqa

        def block0():
            self._rest_subField_with_delF_()
        self._closure(block0)

    @tatsumasu()
    def _rest_subField_with_delF_(self):  # noqa
        self._OptionsSeparator_()
        self._scalarOrView_()
        self.name_last_node('rest_subField')
        self.ast._define(
            ['rest_subField'],
            []
        )

    @tatsumasu()
    def _word_(self):  # noqa

        def block0():
            self._wordPiece_()
        self._positive_closure(block0)

    @tatsumasu()
    def _wordPiece_(self):  # noqa
        with self._choice():
            with self._option():
                self._TypeSpecifier_()
            with self._option():

                def block0():
                    self._OtherWordChars_()
                self._positive_closure(block0)
            self._error('expecting one of: /[0-9ACEGHJ-LN-RT-Z_aceghj-ln-rt-z]/ /[BDFIMSbdfims]/ OtherWordChars TypeSpecifier')

    @tatsumasu()
    def _SubFieldsStart_(self):  # noqa
        self._token('[')

    @tatsumasu()
    def _SubFieldsEnd_(self):  # noqa
        self._token(']')

    @tatsumasu()
    def _Colon_(self):  # noqa
        self._token(':')

    @tatsumasu()
    def _OptionsSeparator_(self):  # noqa
        self._token(',')

    @tatsumasu()
    def _IndirectMarker_(self):  # noqa
        self._token('^')

    @tatsumasu()
    def _OtherWordChars_(self):  # noqa
        self._pattern('[0-9ACEGHJ-LN-RT-Z_aceghj-ln-rt-z]')

    @tatsumasu()
    def _OtherWordCharsOther_(self):  # noqa
        self._pattern('[0-9_]')

    @tatsumasu()
    def _OtherWordCharsUpper_(self):  # noqa
        self._pattern('[ACEGHJ-LN-RT-Z]')

    @tatsumasu()
    def _OtherWordCharsLower_(self):  # noqa
        self._pattern('[aceghj-ln-rt-z]')

    @tatsumasu()
    def _TypeSpecifier_(self):  # noqa
        self._pattern('[BDFIMSbdfims]')

    @tatsumasu()
    def _TypeSpecifierUpper_(self):  # noqa
        self._pattern('[BDFIMS]')

    @tatsumasu()
    def _TypeSpecifierLower_(self):  # noqa
        self._pattern('[bdfims]')


class metakit4_definition_stringSemantics(object):
    def subFields(self, ast):  # noqa
        return ast

    def scalarOrView(self, ast):  # noqa
        return ast

    def view(self, ast):  # noqa
        return ast

    def scalar(self, ast):  # noqa
        return ast

    def body(self, ast):  # noqa
        return ast

    def rest_subFields_with_delF(self, ast):  # noqa
        return ast

    def rest_subField_with_delF(self, ast):  # noqa
        return ast

    def word(self, ast):  # noqa
        return ast

    def wordPiece(self, ast):  # noqa
        return ast

    def SubFieldsStart(self, ast):  # noqa
        return ast

    def SubFieldsEnd(self, ast):  # noqa
        return ast

    def Colon(self, ast):  # noqa
        return ast

    def OptionsSeparator(self, ast):  # noqa
        return ast

    def IndirectMarker(self, ast):  # noqa
        return ast

    def OtherWordChars(self, ast):  # noqa
        return ast

    def OtherWordCharsOther(self, ast):  # noqa
        return ast

    def OtherWordCharsUpper(self, ast):  # noqa
        return ast

    def OtherWordCharsLower(self, ast):  # noqa
        return ast

    def TypeSpecifier(self, ast):  # noqa
        return ast

    def TypeSpecifierUpper(self, ast):  # noqa
        return ast

    def TypeSpecifierLower(self, ast):  # noqa
        return ast


def main(filename, start=None, **kwargs):
    if start is None:
        start = 'subFields'
    if not filename or filename == '-':
        text = sys.stdin.read()
    else:
        with open(filename) as f:
            text = f.read()
    parser = metakit4_definition_stringParser()
    return parser.parse(text, rule_name=start, filename=filename, **kwargs)


if __name__ == '__main__':
    import json
    from tatsu.util import asjson

    ast = generic_main(main, metakit4_definition_stringParser, name='metakit4_definition_string')
    print('AST:')
    print(ast)
    print()
    print('JSON:')
    print(json.dumps(asjson(ast), indent=2))
    print()
